package Ex0;

import java.util.HashMap;
import java.util.List;

public class Graph_Algo implements graph_algorithms {

	private graph g_alg;
	
	public Graph_Algo(graph g) {
		//g_alg=new Graph_DS((Graph_DS)g);
		g_alg = g;
	}
	/**
	 * Init the graph on which this set of algorithms operates on.
	 * @param g
	 */
	public void init(graph g) {
		g_alg = g;
	}
	/** 
	 * Compute a deep copy of this graph.
	 * @return
	 */
	public graph copy() {
		graph g  = new Graph_DS();
		HashMap<Integer,Integer> keymap = new HashMap<Integer,Integer>();
		for (node_data i : g_alg.getV()) {
			node_data n = new NodeData();
			keymap.put(i.getKey(),n.getKey());
			g.addNode(n);
		}
		for (node_data i : g_alg.getV()) {
			int key = i.getKey(); 
			for (node_data j : g_alg.getV(key)) {
				g.connect(keymap.get(key), keymap.get(j.getKey()));
			}
		}
		return g;
	}
/**
 * Returns true if and only if (iff) there is a valid path from EVREY node to each
 * other node. NOTE: assume ubdirectional graph.
 * @return
 */
	public boolean isConnected() {
	return false;
}
	/**
	 * returns the length of the shortest path between src to dest
	 * @param src - start node
	 * @param dest - end (target) node
	 * @return
	 */
	public int shortestPathDist(int src, int dest) {
		return 0;
	}
	/**
	 * returns the the shortest path between src to dest - as an ordered List of nodes:
	 * src--> n1-->n2-->...dest
	 * see: https://en.wikipedia.org/wiki/Shortest_path_problem
	 * @param src - start node
	 * @param dest - end (target) node
	 * @return
	 */
	public List<node_data> shortestPath(int src, int dest) {
		return null;
	}

}

